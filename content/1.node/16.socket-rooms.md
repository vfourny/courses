---
title: Rooms
description: 'Apprenez à organiser vos clients Socket.IO en groupes avec les rooms'
icon: simple-icons:googleclassroom
---

## Introduction aux Rooms

Les **rooms** (salles) sont une fonctionnalité puissante de Socket.IO qui permet de regrouper des clients pour envoyer
des messages uniquement à un sous-ensemble de connexions. C'est très utile pour créer des salons de discussion, des
parties de jeux multijoueurs, ou des canaux thématiques.

Contrairement à la communication globale où tous les clients reçoivent les messages, les rooms permettent de cibler
précisément les destinataires.

> **Note :** Les rooms fonctionnent encore mieux quand elles sont combinées avec l'authentification (vue au chapitre
> précédent). Vous pouvez ainsi créer des rooms privées accessibles uniquement à certains utilisateurs authentifiés.

## Concept des rooms

Une room est simplement un canal arbitraire dans lequel les sockets peuvent rejoindre et quitter. Chaque socket peut
être dans plusieurs rooms à la fois.

```typescript
// Un client rejoint une room
socket.join('room-name')

// Un client quitte une room
socket.leave('room-name')

// Envoyer un message à tous les clients d'une room
io.to('room-name').emit('message', 'Hello!')

// Envoyer à une room sauf à l'émetteur
socket.to('room-name').emit('message', 'Hello!')
```

> **Remarque :** Chaque socket rejoint automatiquement une room portant son propre ID (`socket.id`). Cela permet
> d'envoyer des messages à un client spécifique.

## Méthodes principales

| Méthode                  | Description                                          |
| ------------------------ | ---------------------------------------------------- |
| `socket.join(room)`      | Fait rejoindre une room au client                    |
| `socket.leave(room)`     | Fait quitter une room au client                      |
| `io.to(room).emit()`     | Envoie à tous les clients de la room                 |
| `socket.to(room).emit()` | Envoie à tous les clients de la room sauf l'émetteur |
| `io.in(room).emit()`     | Alias de `to()`                                      |
| `socket.rooms`           | Set contenant toutes les rooms du socket             |

### Différence entre to() et in()

Les méthodes `to()` et `in()` sont des alias - elles font exactement la même chose. Utilisez celle qui rend votre code
plus lisible :

```typescript
// Ces deux lignes sont équivalentes
io.to('room-name').emit('message', 'Hello')
io.in('room-name').emit('message', 'Hello')
```

## Exemple : Chat avec plusieurs salons

Créons un chat avec plusieurs salons de discussion où les utilisateurs peuvent choisir leur salle.

### Serveur (server.ts)

```typescript
import express from 'express'
import { createServer } from 'http'
import { Server } from 'socket.io'

const app = express()
const httpServer = createServer(app)
const io = new Server(httpServer, {
  cors: {
    origin: '*',
  },
})

app.use(express.static('public'))

// Structure pour stocker les informations des rooms
interface RoomInfo {
  users: Map<string, string> // socketId -> username
}

const rooms = new Map<string, RoomInfo>([
  ['general', { users: new Map() }],
  ['javascript', { users: new Map() }],
  ['nodejs', { users: new Map() }],
])

io.on('connection', (socket) => {
  console.log(`Nouvelle connexion : ${socket.id}`)

  // Rejoindre une room
  socket.on('join-room', (data: { room: string; username: string }) => {
    const { room, username } = data

    // Vérifier que la room existe
    if (!rooms.has(room)) {
      socket.emit('error', { message: "Cette room n'existe pas" })
      return
    }

    // Rejoindre la room
    socket.join(room)
    const roomInfo = rooms.get(room)!
    roomInfo.users.set(socket.id, username)

    // Notifier les autres utilisateurs de la room
    socket.to(room).emit('user-joined', {
      username,
      room,
      userCount: roomInfo.users.size,
    })

    // Envoyer la liste des utilisateurs au nouveau venu
    socket.emit('room-users', {
      room,
      users: Array.from(roomInfo.users.values()),
    })

    console.log(`${username} a rejoint la room ${room}`)
  })

  // Quitter une room
  socket.on('leave-room', (room: string) => {
    const roomInfo = rooms.get(room)
    if (roomInfo) {
      const username = roomInfo.users.get(socket.id)
      roomInfo.users.delete(socket.id)
      socket.leave(room)

      // Notifier les autres
      socket.to(room).emit('user-left', {
        username,
        room,
        userCount: roomInfo.users.size,
      })

      console.log(`${username} a quitté la room ${room}`)
    }
  })

  // Message dans une room spécifique
  socket.on('room-message', (data: { room: string; message: string }) => {
    const { room, message } = data
    const roomInfo = rooms.get(room)

    if (roomInfo) {
      const username = roomInfo.users.get(socket.id) || 'Anonyme'

      // Envoyer le message à tous les utilisateurs de la room
      io.to(room).emit('room-message', {
        room,
        username,
        message,
        timestamp: new Date().toISOString(),
      })
    }
  })

  // Liste des rooms disponibles
  socket.on('get-rooms', () => {
    const roomList = Array.from(rooms.entries()).map(([name, info]) => ({
      name,
      userCount: info.users.size,
    }))
    socket.emit('rooms-list', roomList)
  })

  // Déconnexion
  socket.on('disconnect', () => {
    // Retirer l'utilisateur de toutes les rooms
    rooms.forEach((roomInfo, roomName) => {
      if (roomInfo.users.has(socket.id)) {
        const username = roomInfo.users.get(socket.id)
        roomInfo.users.delete(socket.id)

        io.to(roomName).emit('user-left', {
          username,
          room: roomName,
          userCount: roomInfo.users.size,
        })
      }
    })
  })
})

const port = 3000
httpServer.listen(port, () => {
  console.log(`Serveur de chat avec rooms sur http://localhost:${port}`)
})
```

**Côté client :**

```typescript
const socket = io('http://localhost:3000')
const username = prompt('Entrez votre pseudo:') || 'Anonyme'

// Rejoindre une room
socket.emit('join-room', { room: 'general', username })

// Écouter les messages de la room
socket.on('room-message', (data) => {
  console.log(`${data.username}: ${data.message}`)
})

// Envoyer un message dans la room actuelle
socket.emit('room-message', {
  room: 'general',
  message: 'Hello!',
})

// Changer de room
socket.emit('leave-room', 'general')
socket.emit('join-room', { room: 'javascript', username })
```

## Techniques avancées

### Vérifier et gérer les rooms

```typescript
// Voir les rooms d'un socket
console.log(socket.rooms) // Set { socket.id, 'room1', 'room2' }

// Obtenir tous les sockets d'une room
const socketsInRoom = await io.in('room-name').fetchSockets()
console.log(`${socketsInRoom.length} clients dans la room`)

// Envoyer à plusieurs rooms
io.to('room1').to('room2').emit('message', 'Hello!')

// Exclure certains clients
socket.to('room-name').except('socket-id').emit('message', 'Hello!')
```

> **Note :** Les rooms sont créées automatiquement dès qu'un socket les rejoint. `fetchSockets()` est asynchrone.

## Bonnes pratiques

### Nettoyer les données à la déconnexion

```typescript
socket.on('disconnect', () => {
  // Socket.IO retire automatiquement le socket de toutes ses rooms
  // Mais nettoyez vos propres structures de données
  rooms.forEach((roomInfo, roomName) => {
    if (roomInfo.users.has(socket.id)) {
      roomInfo.users.delete(socket.id)
      io.to(roomName).emit('user-left', { roomName })
    }
  })
})
```

### Validation et sécurité

```typescript
socket.on('join-room', (roomName) => {
  // Valider l'existence
  if (!allowedRooms.includes(roomName)) {
    return socket.emit('error', { message: 'Room invalide' })
  }

  // Limiter le nombre de rooms
  if (socket.rooms.size >= 5) {
    return socket.emit('error', { message: 'Trop de rooms' })
  }

  socket.join(roomName)
})

// Utiliser des noms uniques avec préfixes
const roomName = `game:${gameId}`
const chatRoom = `chat:${channelId}`
```

## Pattern : Rooms privées

Voici un pattern courant pour créer des rooms privées entre deux utilisateurs. Ce pattern suppose que vous avez mis en
place l'authentification (voir chapitre précédent) et que les données utilisateur sont stockées dans `socket.data` :

```typescript
// Créer une room privée entre deux utilisateurs
function getPrivateRoomName(userId1: string, userId2: string): string {
  // Toujours le même nom de room quel que soit l'ordre
  const sorted = [userId1, userId2].sort()
  return `private:${sorted[0]}:${sorted[1]}`
}

socket.on(
  'send-private-message',
  (data: { toUserId: string; message: string }) => {
    const roomName = getPrivateRoomName(socket.data.userId, data.toUserId)

    // Les deux utilisateurs rejoignent la room (si ce n'est pas déjà fait)
    socket.join(roomName)

    // Envoyer le message dans cette room
    io.to(roomName).emit('private-message', {
      from: socket.data.userId,
      message: data.message,
    })
  },
)
```

## Résumé

Les rooms Socket.IO sont un outil puissant pour organiser vos clients en groupes et envoyer des messages ciblés. Points
clés à retenir :

- ✅ Les rooms sont créées automatiquement quand un socket les rejoint
- ✅ Un socket peut être dans plusieurs rooms simultanément
- ✅ Utilisez `socket.join()` et `socket.leave()` pour gérer l'appartenance
- ✅ Utilisez `io.to(room).emit()` pour envoyer à tous les clients d'une room
- ✅ N'oubliez pas de nettoyer vos structures de données lors des déconnexions
- ✅ Validez toujours l'existence et les permissions avant de rejoindre une room

Vous maîtrisez maintenant les bases de Socket.IO (connexions, événements), l'authentification, et les rooms. Ces trois
concepts combinés vous permettent de créer des applications temps réel robustes et sécurisées !
