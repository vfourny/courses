---
title: Rooms
description: 'Apprenez à organiser vos clients Socket.IO en groupes avec les rooms'
icon: simple-icons:googleclassroom
---

## Introduction aux Rooms

Les **rooms** (salles) sont une fonctionnalité puissante de Socket.IO qui permet de regrouper des clients pour envoyer
des messages uniquement à un sous-ensemble de connexions. C'est très utile pour créer des salons de discussion, des
parties de jeux multijoueurs, ou des canaux thématiques.

Contrairement à la communication globale où tous les clients reçoivent les messages, les rooms permettent de cibler
précisément les destinataires.

Dans ce chapitre, nous allons étendre notre classe `AuthenticatedChatServer` du chapitre 15 pour ajouter la gestion
des rooms. Nous verrons comment :

- Créer et gérer des rooms (salons de discussion)
- Permettre aux utilisateurs de rejoindre et quitter des rooms
- Envoyer des messages ciblés à une room spécifique
- Afficher la liste des utilisateurs par room

## Concept des rooms

Une room est simplement un canal arbitraire dans lequel les sockets peuvent rejoindre et quitter. Chaque socket peut
être dans plusieurs rooms à la fois.

```typescript
// Un client rejoint une room
socket.join('room-name')

// Un client quitte une room
socket.leave('room-name')

// Envoyer un message à tous les clients d'une room
io.to('room-name').emit('message', 'Hello!')

// Envoyer à une room sauf à l'émetteur
socket.to('room-name').emit('message', 'Hello!')
```

> **Remarque :** Chaque socket rejoint automatiquement une room portant son propre ID (`socket.id`). Cela permet
> d'envoyer des messages à un client spécifique.

## Méthodes principales

| Méthode                  | Description                                          |
| ------------------------ | ---------------------------------------------------- |
| `socket.join(room)`      | Fait rejoindre une room au client                    |
| `socket.leave(room)`     | Fait quitter une room au client                      |
| `io.to(room).emit()`     | Envoie à tous les clients de la room                 |
| `socket.to(room).emit()` | Envoie à tous les clients de la room sauf l'émetteur |
| `io.in(room).emit()`     | Alias de `to()`                                      |
| `socket.rooms`           | Set contenant toutes les rooms du socket             |

### Différence entre to() et in()

Les méthodes `to()` et `in()` sont des alias - elles font exactement la même chose. Utilisez celle qui rend votre code
plus lisible :

```typescript
// Ces deux lignes sont équivalentes
io.to('room-name').emit('message', 'Hello')
io.in('room-name').emit('message', 'Hello')
```

## Extension avec les rooms

Nous allons créer une classe `RoomChatServer` qui étend `AuthenticatedChatServer` et ajoute la gestion des rooms
(salons de discussion).

### Mise à jour des types

Modifiez `src/socket/types/socket.types.ts` pour ajouter les événements liés aux rooms :

```typescript
// Types pour les événements client → serveur
export interface ClientToServerEvents {
  join: (username: string) => void
  'chat-message': (message: string) => void
  'kick-user': (targetSocketId: string) => void
  'join-room': (room: string) => void
  'leave-room': (room: string) => void
  'room-message': (data: { room: string; message: string }) => void
  'get-rooms': () => void
}

// Types pour les événements serveur → client
export interface ServerToClientEvents {
  'user-joined': (data: { username: string; userCount: number }) => void
  'user-left': (data: { username: string; userCount: number }) => void
  'chat-message': (data: { username: string; message: string; timestamp: string }) => void
  error: (data: { message: string }) => void
  kicked: (data: { reason: string }) => void
  'room-joined': (data: { room: string; users: string[] }) => void
  'room-user-joined': (data: { room: string; username: string; userCount: number }) => void
  'room-user-left': (data: { room: string; username: string; userCount: number }) => void
  'room-message': (data: { room: string; username: string; message: string; timestamp: string }) => void
  'rooms-list': (rooms: { name: string; userCount: number }[]) => void
}

export interface InterServerEvents {}

export interface SocketData {
  userId: string
  username: string
  role: 'user' | 'admin'
}

// Structure pour stocker les informations des rooms
export interface RoomInfo {
  users: Map<string, string> // socketId -> username
}
```

### Classe RoomChatServer

Créez `src/socket/classes/RoomChatServer.ts` :

```typescript
import { Server as HTTPServer } from 'http'
import { AuthenticatedChatServer } from './AuthenticatedChatServer'
import { RoomInfo, SocketData } from '../types/socket.types'

export class RoomChatServer extends AuthenticatedChatServer {
  private rooms: Map<string, RoomInfo>

  constructor(httpServer: HTTPServer) {
    super(httpServer)

    // Initialiser les rooms par défaut
    this.rooms = new Map([
      ['general', { users: new Map() }],
      ['javascript', { users: new Map() }],
      ['nodejs', { users: new Map() }],
    ])

    this.setupRoomHandlers()
  }

  private setupRoomHandlers() {
    const io = this.getIO()

    io.on('connection', (socket) => {
      const userData = socket.data as SocketData

      // Rejoindre une room
      socket.on('join-room', (room: string) => {
        if (!this.rooms.has(room)) {
          return socket.emit('error', { message: "Cette room n'existe pas" })
        }

        socket.join(room)
        const roomInfo = this.rooms.get(room)!
        roomInfo.users.set(socket.id, userData.username)

        // Notifier les autres utilisateurs de la room
        socket.to(room).emit('room-user-joined', {
          room,
          username: userData.username,
          userCount: roomInfo.users.size,
        })

        // Envoyer la liste des utilisateurs au nouveau venu
        socket.emit('room-joined', {
          room,
          users: Array.from(roomInfo.users.values()),
        })

        console.log(`${userData.username} a rejoint la room ${room}`)
      })

      // Quitter une room
      socket.on('leave-room', (room: string) => {
        const roomInfo = this.rooms.get(room)
        if (roomInfo && roomInfo.users.has(socket.id)) {
          roomInfo.users.delete(socket.id)
          socket.leave(room)

          socket.to(room).emit('room-user-left', {
            room,
            username: userData.username,
            userCount: roomInfo.users.size,
          })

          console.log(`${userData.username} a quitté la room ${room}`)
        }
      })

      // Message dans une room spécifique
      socket.on('room-message', (data: { room: string; message: string }) => {
        const { room, message } = data
        const roomInfo = this.rooms.get(room)

        if (roomInfo && roomInfo.users.has(socket.id)) {
          io.to(room).emit('room-message', {
            room,
            username: userData.username,
            message,
            timestamp: new Date().toISOString(),
          })
        }
      })

      // Liste des rooms disponibles
      socket.on('get-rooms', () => {
        const roomList = Array.from(this.rooms.entries()).map(([name, info]) => ({
          name,
          userCount: info.users.size,
        }))
        socket.emit('rooms-list', roomList)
      })

      // Déconnexion : retirer de toutes les rooms
      socket.on('disconnect', () => {
        this.rooms.forEach((roomInfo, roomName) => {
          if (roomInfo.users.has(socket.id)) {
            roomInfo.users.delete(socket.id)

            io.to(roomName).emit('room-user-left', {
              room: roomName,
              username: userData.username,
              userCount: roomInfo.users.size,
            })
          }
        })
      })
    })
  }

  public getRoomCount(): number {
    return this.rooms.size
  }

  public getRoomUsers(roomName: string): string[] {
    const room = this.rooms.get(roomName)
    return room ? Array.from(room.users.values()) : []
  }
}
```

### Point d'entrée

Modifiez `src/index.ts` pour utiliser `RoomChatServer` :

```typescript
import express from 'express'
import { createServer } from 'http'
import { RoomChatServer } from './socket/classes/RoomChatServer'
import { authRouter } from './routes/auth.routes'

const app = express()
const httpServer = createServer(app)

app.use(express.json())
app.use(express.static('public'))

// Routes API
app.use('/api', authRouter)

// Initialiser le serveur de chat avec rooms
const chatServer = new RoomChatServer(httpServer)

app.get('/', (_req, res) => {
  res.send('Serveur Socket.IO avec authentification et rooms')
})

const port = 3000
httpServer.listen(port, () => {
  console.log(`Serveur démarré sur http://localhost:${port}`)
  console.log(`Nombre de rooms: ${chatServer.getRoomCount()}`)
})
```

## Client HTML avec sélecteur de rooms

Créez `public/chat-rooms.html` :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Chat avec Rooms</title>
  <style>
    body { font-family: Arial; max-width: 700px; margin: 50px auto; padding: 20px; }
    #loginForm, #chatContainer { display: none; }
    #loginForm.active, #chatContainer.active { display: block; }
    input { padding: 8px; margin: 5px 0; }
    button { padding: 8px 16px; margin: 5px; }
    #messages { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
    .system { color: #666; font-style: italic; }
    .error { color: red; }
    #roomButtons button { background: #f0f0f0; }
    #roomButtons button.active { background: #4CAF50; color: white; }
    #usersList { font-size: 0.9em; color: #666; }
  </style>
</head>
<body>
  <h1>Chat avec Rooms</h1>

  <div id="loginForm" class="active">
    <h2>Connexion</h2>
    <input type="text" id="username" placeholder="Username (admin ou user)" />
    <input type="password" id="password" placeholder="Password" />
    <button id="loginButton">Se connecter</button>
    <p id="loginError" class="error"></p>
    <p><small>Comptes : admin/admin123 ou user/user123</small></p>
  </div>

  <div id="chatContainer">
    <p>Connecté : <strong id="currentUser"></strong></p>
    <div>
      <strong>Rooms disponibles :</strong>
      <div id="roomButtons">
        <button data-room="general">General</button>
        <button data-room="javascript">JavaScript</button>
        <button data-room="nodejs">Node.js</button>
      </div>
    </div>
    <p id="currentRoomInfo">Room actuelle : <strong id="currentRoom">-</strong> (<span id="userCount">0</span> utilisateurs)</p>
    <p id="usersList"></p>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Votre message..." style="width: 70%;" />
    <button id="sendButton">Envoyer</button>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    let socket, currentRoom = null

    document.getElementById('loginButton').addEventListener('click', async () => {
      const username = document.getElementById('username').value.trim()
      const password = document.getElementById('password').value.trim()
      const loginError = document.getElementById('loginError')
      loginError.textContent = ''

      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        })

        if (!response.ok) {
          const error = await response.json()
          loginError.textContent = error.error || 'Erreur de connexion'
          return
        }

        const { token, username: user } = await response.json()
        document.getElementById('loginForm').classList.remove('active')
        document.getElementById('chatContainer').classList.add('active')
        document.getElementById('currentUser').textContent = user
        connectToChat(token)
      } catch (error) {
        loginError.textContent = 'Erreur réseau'
      }
    })

    function connectToChat(token) {
      socket = io('http://localhost:3000', { auth: { token } })
      const messagesDiv = document.getElementById('messages')
      const messageInput = document.getElementById('messageInput')

      function addMessage(content, isSystem = false) {
        const p = document.createElement('p')
        p.className = isSystem ? 'system' : ''
        p.textContent = content
        messagesDiv.appendChild(p)
        messagesDiv.scrollTop = messagesDiv.scrollHeight
      }

      socket.on('connect', () => addMessage('Connecté au serveur', true))
      socket.on('connect_error', (error) => addMessage(`Erreur: ${error.message}`, true))

      // Gestion des rooms
      socket.on('room-joined', (data) => {
        currentRoom = data.room
        document.getElementById('currentRoom').textContent = data.room
        document.getElementById('usersList').textContent = `Utilisateurs: ${data.users.join(', ')}`
        addMessage(`Vous avez rejoint #${data.room}`, true)
        updateActiveRoomButton(data.room)
      })

      socket.on('room-user-joined', (data) => {
        if (data.room === currentRoom) {
          addMessage(`${data.username} a rejoint`, true)
          document.getElementById('userCount').textContent = data.userCount
        }
      })

      socket.on('room-user-left', (data) => {
        if (data.room === currentRoom) {
          addMessage(`${data.username} a quitté`, true)
          document.getElementById('userCount').textContent = data.userCount
        }
      })

      socket.on('room-message', (data) => {
        if (data.room === currentRoom) {
          const time = new Date(data.timestamp).toLocaleTimeString()
          addMessage(`[${time}] ${data.username}: ${data.message}`)
        }
      })

      socket.on('error', (data) => addMessage(`Erreur: ${data.message}`, true))

      // Boutons de rooms
      document.querySelectorAll('#roomButtons button').forEach(button => {
        button.addEventListener('click', () => {
          const room = button.dataset.room
          if (currentRoom) socket.emit('leave-room', currentRoom)
          socket.emit('join-room', room)
        })
      })

      // Envoi de message
      document.getElementById('sendButton').addEventListener('click', () => {
        const message = messageInput.value.trim()
        if (message && currentRoom) {
          socket.emit('room-message', { room: currentRoom, message })
          messageInput.value = ''
        }
      })

      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') document.getElementById('sendButton').click()
      })

      function updateActiveRoomButton(room) {
        document.querySelectorAll('#roomButtons button').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.room === room)
        })
      }
    }
  </script>
</body>
</html>
```

Ce client (~100 lignes) gère :
- Authentification avec login/password
- Sélection de room via boutons
- Affichage de la room actuelle et des utilisateurs
- Envoi de messages dans la room sélectionnée
- Changement de room dynamique

## Techniques avancées

### Vérifier et gérer les rooms

```typescript
// Voir les rooms d'un socket
console.log(socket.rooms) // Set { socket.id, 'room1', 'room2' }

// Obtenir tous les sockets d'une room
const socketsInRoom = await io.in('room-name').fetchSockets()
console.log(`${socketsInRoom.length} clients dans la room`)

// Envoyer à plusieurs rooms
io.to('room1').to('room2').emit('message', 'Hello!')

// Exclure certains clients
socket.to('room-name').except('socket-id').emit('message', 'Hello!')
```

> **Note :** Les rooms sont créées automatiquement dès qu'un socket les rejoint. `fetchSockets()` est asynchrone.

## Bonnes pratiques

### 1. Nettoyage automatique

Socket.IO retire automatiquement les sockets de leurs rooms lors de la déconnexion. Assurez-vous de nettoyer vos
propres structures de données :

```typescript
socket.on('disconnect', () => {
  rooms.forEach((roomInfo, roomName) => {
    if (roomInfo.users.has(socket.id)) {
      roomInfo.users.delete(socket.id)
      io.to(roomName).emit('user-left', { username, room: roomName })
    }
  })
})
```

### 2. Validation et sécurité

Validez toujours l'existence des rooms et limitez le nombre de rooms par utilisateur :

```typescript
socket.on('join-room', (roomName) => {
  if (!this.rooms.has(roomName)) {
    return socket.emit('error', { message: 'Room invalide' })
  }

  if (socket.rooms.size >= 5) {
    return socket.emit('error', { message: 'Limite de rooms atteinte' })
  }

  socket.join(roomName)
})
```

### 3. Pattern rooms privées

Pour créer des rooms privées entre deux utilisateurs :

```typescript
function getPrivateRoomName(userId1: string, userId2: string): string {
  const sorted = [userId1, userId2].sort()
  return `private:${sorted[0]}:${sorted[1]}`
}

socket.on('send-private-message', (data: { toUserId: string; message: string }) => {
  const roomName = getPrivateRoomName(socket.data.userId, data.toUserId)
  socket.join(roomName)
  io.to(roomName).emit('private-message', {
    from: socket.data.userId,
    message: data.message,
  })
})
```

## Résumé

Nous avons construit une application de chat complète en trois étapes :

**Chapitre 14 - Bases Socket.IO :**
- ✅ Architecture modulaire (types, handlers, classes)
- ✅ Communication bidirectionnelle temps réel
- ✅ Classe `ChatServer` avec gestion des utilisateurs

**Chapitre 15 - Authentification :**
- ✅ Extension avec `AuthenticatedChatServer`
- ✅ Middlewares pour validation JWT
- ✅ Gestion des rôles et permissions

**Chapitre 16 - Rooms :**
- ✅ Extension avec `RoomChatServer`
- ✅ Organisation en salons de discussion
- ✅ Messages ciblés par room

L'approche orientée objet avec héritage nous a permis d'étendre facilement notre application à chaque chapitre sans
réécrire le code existant. Vous disposez maintenant d'une base solide pour créer des applications temps réel
professionnelles !
