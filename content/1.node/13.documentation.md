---
title: Documentation
description: Documenter son code avec JSDoc et son API avec OpenApi
icon: mdi:file-document
---

La documentation est essentielle pour maintenir un code de qualité et faciliter le travail d'équipe. Dans ce chapitre,
nous allons voir deux approches complémentaires :

1. **JSDoc** : Pour documenter le code TypeScript/JavaScript (fonctions, classes, types)
2. **OpenAPI** : Pour documenter l'API REST (endpoints, paramètres, réponses)

## JSDoc

- **Améliore la lisibilité** : Les développeurs comprennent immédiatement ce que fait une fonction
- **Autocomplete améliorée** : Les IDE peuvent afficher la documentation en temps réel
- **Génération automatique** : Possibilité de générer une documentation HTML
- **Typage pour JavaScript** : Permet d'ajouter des types dans des fichiers `.js` (même si TypeScript est préférable)
- **Maintenance facilitée** : Les changements dans le code sont documentés au même endroit

### Syntaxe de base

JSDoc utilise des commentaires spéciaux qui commencent par `/**` et se terminent par `*/`.

```typescript
/**
 * Description de la fonction
 * @param parametre1 - Description du paramètre
 * @param parametre2 - Description du paramètre
 * @returns Description de la valeur retournée
 */
function maFonction(parametre1: string, parametre2: number): boolean {
    return true
}
```

### Tags JSDoc courants

Voici les tags les plus utilisés :

| Tag           | Description                      | Exemple                                       |
|---------------|----------------------------------|-----------------------------------------------|
| `@param`      | Décrit un paramètre              | `@param {string} name - Nom de l'utilisateur` |
| `@returns`    | Décrit la valeur retournée       | `@returns {Promise<User>} L'utilisateur créé` |
| `@throws`     | Décrit les erreurs possibles     | `@throws {Error} Si l'email est invalide`     |
| `@example`    | Fournit un exemple d'utilisation | `@example const user = await getUser(1);`     |
| `@deprecated` | Marque comme obsolète            | `@deprecated Utiliser getUser() à la place`   |
| `@see`        | Référence à une autre fonction   | `@see {@link createUser}`                     |
| `@async`      | Indique une fonction asynchrone  | `@async`                                      |
| `@typedef`    | Définit un type personnalisé     | `@typedef {Object} User`                      |
| `@property`   | Propriété d'un objet             | `@property {number} id`                       |

### Bonnes pratiques JSDoc

1. **Documentez les fonctions publiques** : Toutes les fonctions exportées doivent avoir une documentation
2. **Soyez concis mais précis** : Décrivez clairement ce que fait la fonction sans être verbeux
3. **Ajoutez des exemples** : Pour les fonctions complexes, un exemple vaut mieux qu'une longue explication
4. **Documentez les erreurs** : Utilisez `@throws` pour décrire les erreurs possibles
5. **Gardez la documentation à jour** : Mettez à jour les commentaires quand vous modifiez le code
6. **Évitez les évidences** : Ne documentez pas `@param id - The ID` → préférez expliquer ce que représente l'ID

## OpenAPI

#### Pourquoi documenter une API ?

- **Faciliter la compréhension** : Les développeurs savent exactement comment interagir avec l'API (endpoints,
  paramètres, types de données)
- **Réduire les erreurs** : Les spécifications claires minimisent le risque d'erreurs lors de l'intégration de l'API
- **Améliorer la maintenabilité** : La documentation facilite l'évolution et l'extension de l'API
- **Interface de test intégrée** : Swagger UI permet de tester directement les endpoints depuis le navigateur

**OpenAPI** est une spécification standardisée pour décrire les API REST. **Swagger** est l'ensemble d'outils qui
exploite cette spécification.

#### Composants principaux

- **Spécification OpenAPI** : Format de fichier (YAML ou JSON) décrivant toutes les routes, paramètres et réponses de
  l'API
- **Swagger UI** : Interface web interactive pour visualiser et tester la documentation
- **Version actuelle** : OpenAPI 3.1.0 (compatible JSON Schema)

### TSOA

TSOA est un framework TypeScript qui génère **automatiquement** votre documentation OpenAPI et vos routes Express à
partir de décorateurs. C'est l'approche la moins verbeuse et la plus type-safe.

#### Avantages de TSOA

:icon{name="i-heroicons-check-circle" class="text-green-500"} **Zéro verbosité** : Pas de commentaires JSDoc massifs, le
code TypeScript suffit

:icon{name="i-heroicons-check-circle" class="text-green-500"} **Type-safety garantie** : Les types TypeScript =
documentation automatique

:icon{name="i-heroicons-check-circle" class="text-green-500"} **Génération automatique** : Routes Express ET
spécification OpenAPI générées

:icon{name="i-heroicons-check-circle" class="text-green-500"} **Validation automatique** : Les requêtes sont validées
selon vos types

:icon{name="i-heroicons-check-circle" class="text-green-500"} **Maintenance facilitée** : Une modification de type =
mise à jour de la doc

**Installation**

```bash
npm install tsoa
```

**Configuration tsoa.json**

Créez un fichier `tsoa.json` à la racine :

```json
{
  "entryFile": "src/index.ts",
  "noImplicitAdditionalProperties": "throw-on-extras",
  "controllerPathGlobs": [
    "src/controllers/**/*.ts"
  ],
  "spec": {
    "outputDirectory": "src/generated",
    "specVersion": 3,
    "securityDefinitions": {
      "jwt": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  },
  "routes": {
    "routesDir": "src/generated",
    "middleware": "express",
    "authenticationModule": "./src/middleware/authentication.ts"
  }
}
```

**Scripts package.json**

Ajoutez ces scripts :

```json
{
  "scripts": {
    "tsoa:spec": "tsoa spec",
    "tsoa:routes": "tsoa routes",
    "tsoa:gen": "npm run tsoa:spec && npm run tsoa:routes",
    "dev": "npm run tsoa:gen && tsx ./src/index.ts"
  }
}
```

### Définir vos modèles

Créez `src/models/User.ts` :

```typescript
/**
 * Représente un utilisateur dans le système
 */
export interface User {
    /** Identifiant unique */
    id: number
    /** Nom complet */
    name: string
    /** Adresse email */
    email: string
}

/**
 * Données pour créer un utilisateur
 */
export interface CreateUserDto {
    /** Nom complet de l'utilisateur */
    name: string
    /** Email unique */
    email: string
    /** Mot de passe (minimum 8 caractères) */
    password: string
}

/**
 * Données de connexion
 */
export interface LoginDto {
    email: string
    password: string
}

/**
 * Réponse de connexion avec token JWT
 */
export interface LoginResponse {
    message: string
    token: string
    user: User
}
```

### Créer un contrôleur

Créez `src/controllers/AuthController.ts` :

```typescript
import {
    Body,
    Controller,
    Post,
    Route,
    Tags,
    Response,
    SuccessResponse,
} from 'tsoa'
import {LoginDto, LoginResponse, CreateUserDto, User} from '../models/User'

@Route('auth')
@Tags('Authentication')
export class AuthController extends Controller {
    /**
     * Authentifie un utilisateur et retourne un JWT
     */
    @Post('login')
    @SuccessResponse('200', 'Connexion réussie')
    @Response('401', 'Email ou mot de passe incorrect')
    public async login(@Body() body: LoginDto): Promise<LoginResponse> {
        // Logique d'authentification
        const user = await database.findUserByEmail(body.email)

        if (!user || !(await bcrypt.compare(body.password, user.password))) {
            this.setStatus(401)
            throw new Error('Email ou mot de passe incorrect')
        }

        const token = jwt.sign({userId: user.id}, process.env.JWT_SECRET!)

        return {
            message: 'Connexion réussie',
            token,
            user: {id: user.id, name: user.name, email: user.email},
        }
    }

    /**
     * Inscription d'un nouvel utilisateur
     */
    @Post('register')
    @SuccessResponse('201', 'Utilisateur créé')
    @Response('400', 'Email déjà utilisé')
    public async register(@Body() body: CreateUserDto): Promise<User> {
        this.setStatus(201)

        // Vérifier si l'email existe
        const existingUser = await database.findUserByEmail(body.email)
        if (existingUser) {
            this.setStatus(400)
            throw new Error('Email déjà utilisé')
        }

        // Hasher le mot de passe et créer l'utilisateur
        const hashedPassword = await bcrypt.hash(body.password, 10)
        const user = await database.createUser({
            ...body,
            password: hashedPassword,
        })

        return {id: user.id, name: user.name, email: user.email}
    }
}
```

### Contrôleur avec authentification

Créez `src/controllers/UserController.ts` :

```typescript
import {
    Controller,
    Get,
    Post,
    Route,
    Tags,
    Path,
    Body,
    Security,
    Request,
} from 'tsoa'
import {User, CreateUserDto} from '../models/User'
import type {Request as ExpressRequest} from 'express'

@Route('users')
@Tags('Users')
export class UserController extends Controller {
    /**
     * Récupère la liste de tous les utilisateurs
     */
    @Get()
    public async getUsers(): Promise<User[]> {
        const users = await database.getAllUsers()
        return users
    }

    /**
     * Récupère un utilisateur par son ID
     */
    @Get('{id}')
    @Response('404', 'Utilisateur non trouvé')
    public async getUser(@Path() id: number): Promise<User> {
        const user = await database.findUserById(id)

        if (!user) {
            this.setStatus(404)
            throw new Error('Utilisateur non trouvé')
        }

        return user
    }

    /**
     * Crée un nouvel utilisateur (nécessite authentification)
     */
    @Post()
    @Security('jwt')
    @SuccessResponse('201', 'Utilisateur créé')
    @Response('401', 'Non autorisé')
    public async createUser(
        @Body() body: CreateUserDto,
        @Request() request: ExpressRequest,
    ): Promise<User> {
        this.setStatus(201)

        // request.user est disponible grâce au middleware d'authentification
        const currentUser = (request as any).user

        const hashedPassword = await bcrypt.hash(body.password, 10)
        const user = await database.createUser({
            ...body,
            password: hashedPassword,
        })

        return user
    }
}
```

### Middleware d'authentification

Créez `src/middleware/authentication.ts` :

```typescript
import {Request} from 'express'
import jwt from 'jsonwebtoken'

export async function expressAuthentication(
    request: Request,
    securityName: string,
    scopes?: string[],
): Promise<any> {
    if (securityName === 'jwt') {
        const token = request.headers.authorization?.split(' ')[1]

        if (!token) {
            throw new Error('Token manquant')
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET!)
            return decoded
        } catch (error) {
            throw new Error('Token invalide')
        }
    }
}
```

### Intégration dans Express

Créez `src/index.ts` :

```typescript
import express from 'express'
import swaggerUi from 'swagger-ui-express'
import {RegisterRoutes} from './generated/routes'

const app = express()
app.use(express.json())

// Routes générées automatiquement par TSOA
RegisterRoutes(app)

// Documentation Swagger UI
app.use('/api-docs', swaggerUi.serve, async (_req, res) => {
    const swaggerDocument = await import('./generated/swagger.json')
    return res.send(swaggerUi.generateHTML(swaggerDocument))
})

app.listen(3000, () => {
    console.log('Server: http://localhost:3000')
    console.log('API Docs: http://localhost:3000/api-docs')
})
```

#### Génération de la documentation

Exécutez :

```bash
npm run tsoa:gen
```

Cela génère :

- **`src/generated/swagger.json`** : Spécification OpenAPI complète
- **`src/generated/routes.ts`** : Routes Express avec validation automatique

### Décorateurs TSOA courants

| Décorateur           | Description                             | Exemple                           |
|----------------------|-----------------------------------------|-----------------------------------|
| `@Route()`           | Définit le chemin de base du contrôleur | `@Route('users')`                 |
| `@Tags()`            | Groupe les endpoints dans Swagger UI    | `@Tags('Authentication')`         |
| `@Get()`             | Route GET                               | `@Get('{id}')`                    |
| `@Post()`            | Route POST                              | `@Post('login')`                  |
| `@Put()`             | Route PUT                               | `@Put('{id}')`                    |
| `@Delete()`          | Route DELETE                            | `@Delete('{id}')`                 |
| `@Path()`            | Paramètre d'URL                         | `@Path() id: number`              |
| `@Body()`            | Corps de la requête                     | `@Body() data: CreateUserDto`     |
| `@Query()`           | Paramètre query string                  | `@Query() search?: string`        |
| `@Header()`          | Header HTTP                             | `@Header() authorization: string` |
| `@Security()`        | Sécurité requise                        | `@Security('jwt')`                |
| `@SuccessResponse()` | Code de succès                          | `@SuccessResponse('201')`         |
| `@Response()`        | Code d'erreur                           | `@Response('404', 'Not found')`   |

TSOA valide automatiquement les données selon vos types TypeScript :

```typescript
export interface CreateUserDto {
    name: string // Requis, type string
    email: string // Requis, type string
    age?: number // Optionnel, type number
    role: 'admin' | 'user' // Enum, uniquement ces valeurs
}
```

Si un client envoie des données invalides, TSOA retourne automatiquement une erreur 400.

### Tester la documentation

Lancez votre serveur :

```bash
npm run dev
```

Accédez à `http://localhost:3000/api-docs` pour voir :

- **Documentation interactive** générée automatiquement
- **Tous les types TypeScript** convertis en schémas OpenAPI
- **Bouton "Try it out"** pour tester les endpoints
- **Authentification JWT** via le bouton "Authorize"
