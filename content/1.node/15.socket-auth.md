---
title: Socket Auth
description: 'Sécurisez vos connexions Socket.IO avec l\'authentification et les middlewares'
icon: mdi:shield-lock
---

## Introduction

L'authentification est cruciale pour sécuriser vos applications temps réel. Sans elle, n'importe qui pourrait se connecter à votre serveur et accéder à des données sensibles.

Dans ce chapitre :

- Middlewares Socket.IO pour valider les connexions
- Authentification avec JWT
- Stockage de données utilisateur

## Middlewares Socket.IO

Les middlewares s'exécutent **avant** l'établissement d'une connexion. Ils permettent de valider ou rejeter une connexion.

### Syntaxe

```typescript
io.use((socket, next) => {
  if (isValid) {
    next() // Autoriser
  } else {
    next(new Error('Authentification échouée')) // Rejeter
  }
})
```

### Exemple : Vérifier un token

```typescript
import { Server } from 'socket.io'
import { createServer } from 'http'

const httpServer = createServer()
const io = new Server(httpServer)

io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token || token !== 'secret-token') {
    return next(new Error('Token invalide'))
  }

  next()
})

io.on('connection', (socket) => {
  console.log('Client authentifié:', socket.id)
})

httpServer.listen(3000)
```

**Côté client :**

```typescript
const socket = io('http://localhost:3000', {
  auth: { token: 'secret-token' },
})

socket.on('connect_error', (error) => {
  console.error('Erreur:', error.message)
})
```

## Authentification avec JWT

JSON Web Tokens (JWT) est le standard pour sécuriser les applications modernes.

### Installation

```bash
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken
```

### Génération du token

Généralement fait lors de la connexion utilisateur sur votre API REST :

```typescript
import jwt from 'jsonwebtoken'
import express from 'express'

const app = express()
const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

app.post('/login', (req, res) => {
  const { username, password } = req.body

  // Vérifier les identifiants (à implémenter avec votre DB)
  if (username === 'admin' && password === 'password') {
    const token = jwt.sign(
      { userId: '123', username: 'admin', role: 'admin' },
      SECRET_KEY,
      { expiresIn: '24h' },
    )

    res.json({ token })
  } else {
    res.status(401).json({ error: 'Identifiants invalides' })
  }
})
```

### Vérification dans Socket.IO

```typescript
import { Server } from 'socket.io'
import jwt from 'jsonwebtoken'

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

interface JWTPayload {
  userId: string
  username: string
  role: string
}

io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token) {
    return next(new Error('Token manquant'))
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY) as JWTPayload

    // Stocker les infos dans socket.data
    socket.data = decoded

    next()
  } catch (error) {
    next(new Error('Token invalide'))
  }
})

io.on('connection', (socket) => {
  console.log(`${socket.data.username} connecté`)

  socket.on('message', (data) => {
    // Accès aux données authentifiées
    console.log(`Message de ${socket.data.username}:`, data)
  })
})
```

## Stocker des données utilisateur

Socket.IO 4+ fournit `socket.data` pour stocker des données personnalisées.

### Typage TypeScript

```typescript
interface SocketData {
  userId: string
  username: string
  role: 'user' | 'admin'
}

const io = new Server<
  ClientToServerEvents,
  ServerToClientEvents,
  InterServerEvents,
  SocketData
>(httpServer)

// socket.data est maintenant typé
io.use((socket, next) => {
  const decoded = jwt.verify(token, SECRET_KEY) as JWTPayload
  socket.data = {
    userId: decoded.userId,
    username: decoded.username,
    role: decoded.role,
  }
  next()
})
```

### Vérifier les permissions

```typescript
io.on('connection', (socket) => {
  socket.on('admin-action', (data) => {
    if (socket.data.role !== 'admin') {
      return socket.emit('error', { message: 'Permission refusée' })
    }

    // Action admin autorisée
  })

  socket.on('send-message', (message: string) => {
    io.emit('new-message', {
      from: socket.data.username,
      message,
      timestamp: new Date().toISOString(),
    })
  })
})
```

## Exemple complet

Voici un serveur avec authentification JWT complète :

```typescript
import express from 'express'
import { createServer } from 'http'
import { Server } from 'socket.io'
import jwt from 'jsonwebtoken'

const app = express()
const httpServer = createServer(app)
const io = new Server(httpServer)

app.use(express.json())

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

interface SocketData {
  userId: string
  username: string
  role: 'user' | 'admin'
}

// API de connexion
app.post('/api/login', (req, res) => {
  const { username, password } = req.body

  // Simulation - en production, vérifier en DB
  const users = {
    admin: { password: 'admin123', role: 'admin' as const },
    user: { password: 'user123', role: 'user' as const },
  }

  const user = users[username as keyof typeof users]

  if (!user || user.password !== password) {
    return res.status(401).json({ error: 'Identifiants invalides' })
  }

  const token = jwt.sign(
    { userId: Date.now().toString(), username, role: user.role },
    SECRET_KEY,
    { expiresIn: '24h' },
  )

  res.json({ token, username, role: user.role })
})

// Middleware d'authentification Socket.IO
io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token) {
    return next(new Error('Token manquant'))
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY) as SocketData
    socket.data = decoded
    next()
  } catch (error) {
    next(new Error('Token invalide ou expiré'))
  }
})

// Gestion des connexions
const connectedUsers = new Map<string, SocketData>()

io.on('connection', (socket) => {
  const userData = socket.data
  connectedUsers.set(socket.id, userData)

  console.log(`${userData.username} (${userData.role}) connecté`)

  io.emit('user-joined', {
    username: userData.username,
    userCount: connectedUsers.size,
  })

  socket.on('chat-message', (message: string) => {
    io.emit('chat-message', {
      from: userData.username,
      message,
      timestamp: new Date().toISOString(),
    })
  })

  // Action admin uniquement
  socket.on('kick-user', (targetSocketId: string) => {
    if (userData.role !== 'admin') {
      return socket.emit('error', { message: 'Permission refusée' })
    }

    const targetSocket = io.sockets.sockets.get(targetSocketId)
    if (targetSocket) {
      targetSocket.emit('kicked', { reason: 'Expulsé par un admin' })
      targetSocket.disconnect()
    }
  })

  socket.on('disconnect', () => {
    connectedUsers.delete(socket.id)
    io.emit('user-left', {
      username: userData.username,
      userCount: connectedUsers.size,
    })
  })
})

httpServer.listen(3000, () => {
  console.log('Serveur sur http://localhost:3000')
})
```

**Client :**

```typescript
// Connexion au serveur
const response = await fetch('/api/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ username: 'admin', password: 'admin123' }),
})

const { token } = await response.json()

// Connexion Socket.IO avec le token
const socket = io('http://localhost:3000', {
  auth: { token },
})

socket.on('connect_error', (error) => {
  console.error('Erreur:', error.message)
})

socket.on('chat-message', (data) => {
  console.log(`${data.from}: ${data.message}`)
})

socket.emit('chat-message', 'Hello!')
```

## Bonnes pratiques

### 1. Variables d'environnement

Ne jamais coder en dur les clés secrètes :

```typescript
import dotenv from 'dotenv'
dotenv.config()

const SECRET_KEY = process.env.JWT_SECRET
if (!SECRET_KEY) {
  throw new Error('JWT_SECRET manquant dans .env')
}
```

### 2. Gérer l'expiration

```typescript
io.use((socket, next) => {
  try {
    const decoded = jwt.verify(token, SECRET_KEY)
    socket.data = decoded
    next()
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      next(new Error('Token expiré, reconnectez-vous'))
    } else {
      next(new Error('Token invalide'))
    }
  }
})
```

### 3. Rate limiting

Protégez-vous contre les abus :

```typescript
const rateLimits = new Map<string, number[]>()

socket.on('message', (data) => {
  const now = Date.now()
  const userMessages = rateLimits.get(socket.data.userId) || []

  // Messages des 10 dernières secondes
  const recent = userMessages.filter((time) => now - time < 10000)

  if (recent.length >= 5) {
    return socket.emit('error', { message: 'Trop de messages!' })
  }

  recent.push(now)
  rateLimits.set(socket.data.userId, recent)

  // Traiter le message
})
```

### 4. Validation côté serveur

Toujours valider les permissions avant une action :

```typescript
socket.on('sensitive-action', (data) => {
  if (socket.data.role !== 'admin') {
    return socket.emit('error', { message: 'Permission refusée' })
  }

  // Action autorisée
})
```

## Résumé

L'authentification Socket.IO repose sur :

- ✅ **Middlewares** : Valident les connexions avant établissement
- ✅ **JWT** : Standard sécurisé pour l'authentification
- ✅ **socket.data** : Stockage des infos utilisateur
- ✅ **Validation** : Toujours vérifier les permissions côté serveur
- ✅ **Sécurité** : HTTPS en production, variables d'environnement, rate limiting

Dans le prochain chapitre, nous verrons comment combiner l'authentification avec les **rooms** pour créer des espaces privés !
