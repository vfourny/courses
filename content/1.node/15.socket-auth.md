---
title: Socket Auth
description: 'Sécurisez vos connexions Socket.IO avec l\'authentification et les middlewares'
icon: mdi:shield-lock
---

## Introduction

L'authentification est cruciale pour sécuriser vos applications temps réel. Sans elle, n'importe qui pourrait se connecter à votre serveur et accéder à des données sensibles.

Dans ce chapitre, nous allons étendre notre classe `ChatServer` du chapitre 14 pour ajouter l'authentification JWT. Nous verrons comment :

- Utiliser les middlewares Socket.IO pour valider les connexions
- Implémenter l'authentification avec JWT
- Stocker et utiliser les données utilisateur authentifiées
- Gérer les permissions (rôles admin/user)

## Middlewares Socket.IO

Les middlewares s'exécutent **avant** l'établissement d'une connexion. Ils permettent de valider ou rejeter une connexion.

### Syntaxe

```typescript
io.use((socket, next) => {
  if (isValid) {
    next() // Autoriser
  } else {
    next(new Error('Authentification échouée')) // Rejeter
  }
})
```

### Exemple : Vérifier un token

```typescript
import { Server } from 'socket.io'
import { createServer } from 'http'

const httpServer = createServer()
const io = new Server(httpServer)

io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token || token !== 'secret-token') {
    return next(new Error('Token invalide'))
  }

  next()
})

io.on('connection', (socket) => {
  console.log('Client authentifié:', socket.id)
})

httpServer.listen(3000)
```

**Côté client :**

```typescript
const socket = io('http://localhost:3000', {
  auth: { token: 'secret-token' },
})

socket.on('connect_error', (error) => {
  console.error('Erreur:', error.message)
})
```

## Authentification avec JWT

JSON Web Tokens (JWT) est le standard pour sécuriser les applications modernes.

### Installation

```bash
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken
```

### Génération du token

Généralement fait lors de la connexion utilisateur sur votre API REST :

```typescript
import jwt from 'jsonwebtoken'
import express from 'express'

const app = express()
const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

app.post('/login', (req, res) => {
  const { username, password } = req.body

  // Vérifier les identifiants (à implémenter avec votre DB)
  if (username === 'admin' && password === 'password') {
    const token = jwt.sign(
      { userId: '123', username: 'admin', role: 'admin' },
      SECRET_KEY,
      { expiresIn: '24h' },
    )

    res.json({ token })
  } else {
    res.status(401).json({ error: 'Identifiants invalides' })
  }
})
```

### Vérification dans Socket.IO

```typescript
import { Server } from 'socket.io'
import jwt from 'jsonwebtoken'

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

interface JWTPayload {
  userId: string
  username: string
  role: string
}

io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token) {
    return next(new Error('Token manquant'))
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY) as JWTPayload

    // Stocker les infos dans socket.data
    socket.data = decoded

    next()
  } catch (error) {
    next(new Error('Token invalide'))
  }
})

io.on('connection', (socket) => {
  console.log(`${socket.data.username} connecté`)

  socket.on('message', (data) => {
    // Accès aux données authentifiées
    console.log(`Message de ${socket.data.username}:`, data)
  })
})
```

## Stocker des données utilisateur

Socket.IO 4+ fournit `socket.data` pour stocker des données personnalisées.

### Typage TypeScript

```typescript
interface SocketData {
  userId: string
  username: string
  role: 'user' | 'admin'
}

const io = new Server<
  ClientToServerEvents,
  ServerToClientEvents,
  InterServerEvents,
  SocketData
>(httpServer)

// socket.data est maintenant typé
io.use((socket, next) => {
  const decoded = jwt.verify(token, SECRET_KEY) as JWTPayload
  socket.data = {
    userId: decoded.userId,
    username: decoded.username,
    role: decoded.role,
  }
  next()
})
```

### Vérifier les permissions

```typescript
io.on('connection', (socket) => {
  socket.on('admin-action', (data) => {
    if (socket.data.role !== 'admin') {
      return socket.emit('error', { message: 'Permission refusée' })
    }

    // Action admin autorisée
  })

  socket.on('send-message', (message: string) => {
    io.emit('new-message', {
      from: socket.data.username,
      message,
      timestamp: new Date().toISOString(),
    })
  })
})
```

## Extension de ChatServer avec authentification

Maintenant, nous allons étendre notre classe `ChatServer` pour ajouter l'authentification JWT. Nous créerons une nouvelle classe `AuthenticatedChatServer` qui hérite de `ChatServer`.

### Mise à jour des types

Modifiez `src/socket/types/socket.types.ts` pour ajouter les données utilisateur :

```typescript
// Types pour les événements client → serveur
export interface ClientToServerEvents {
  join: (username: string) => void
  'chat-message': (message: string) => void
  'kick-user': (targetSocketId: string) => void
}

// Types pour les événements serveur → client
export interface ServerToClientEvents {
  'user-joined': (data: { username: string; userCount: number }) => void
  'user-left': (data: { username: string; userCount: number }) => void
  'chat-message': (data: { username: string; message: string; timestamp: string }) => void
  error: (data: { message: string }) => void
  kicked: (data: { reason: string }) => void
}

export interface InterServerEvents {}

// Données stockées dans socket.data après authentification
export interface SocketData {
  userId: string
  username: string
  role: 'user' | 'admin'
}
```

### Route de login

Créez `src/routes/auth.routes.ts` :

```typescript
import { Router } from 'express'
import jwt from 'jsonwebtoken'

export const authRouter = Router()

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'

// Base de données simulée
const users = {
  admin: { password: 'admin123', role: 'admin' as const },
  user: { password: 'user123', role: 'user' as const },
}

authRouter.post('/login', (req, res) => {
  const { username, password } = req.body

  const user = users[username as keyof typeof users]

  if (!user || user.password !== password) {
    return res.status(401).json({ error: 'Identifiants invalides' })
  }

  const token = jwt.sign(
    { userId: Date.now().toString(), username, role: user.role },
    SECRET_KEY,
    { expiresIn: '24h' },
  )

  res.json({ token, username, role: user.role })
})
```

### Classe AuthenticatedChatServer

Créez `src/socket/classes/AuthenticatedChatServer.ts` :

```typescript
import { Server as HTTPServer } from 'http'
import jwt from 'jsonwebtoken'
import { ChatServer } from './ChatServer'
import { SocketData } from '../types/socket.types'

export class AuthenticatedChatServer extends ChatServer {
  private readonly SECRET_KEY: string

  constructor(httpServer: HTTPServer) {
    super(httpServer)
    this.SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key'
    this.setupAuthMiddleware()
  }

  private setupAuthMiddleware() {
    const io = this.getIO()

    io.use((socket, next) => {
      const token = socket.handshake.auth.token

      if (!token) {
        return next(new Error('Token manquant'))
      }

      try {
        const decoded = jwt.verify(this.SECRET_KEY, this.SECRET_KEY) as SocketData
        socket.data = decoded
        next()
      } catch (error) {
        next(new Error('Token invalide ou expiré'))
      }
    })

    // Ajouter les handlers spécifiques à l'authentification
    io.on('connection', (socket) => {
      this.setupAuthHandlers(socket)
    })
  }

  private setupAuthHandlers(socket: any) {
    const userData = socket.data as SocketData
    console.log(`${userData.username} (${userData.role}) connecté`)

    // Action admin : expulser un utilisateur
    socket.on('kick-user', (targetSocketId: string) => {
      if (userData.role !== 'admin') {
        return socket.emit('error', { message: 'Permission refusée' })
      }

      const io = this.getIO()
      const targetSocket = io.sockets.sockets.get(targetSocketId)
      if (targetSocket) {
        targetSocket.emit('kicked', { reason: 'Expulsé par un admin' })
        targetSocket.disconnect()
      }
    })
  }

  protected override handleJoin(socket: any, username: string) {
    // Utiliser le username du token au lieu du username envoyé
    const authenticatedUsername = (socket.data as SocketData).username
    super.handleJoin(socket, authenticatedUsername)
  }
}
```

> **Note :** Nous utilisons `override` pour surcharger la méthode `handleJoin` et utiliser le username authentifié au lieu
> de celui envoyé par le client.

### Point d'entrée

Modifiez `src/index.ts` :

```typescript
import express from 'express'
import { createServer } from 'http'
import { AuthenticatedChatServer } from './socket/classes/AuthenticatedChatServer'
import { authRouter } from './routes/auth.routes'

const app = express()
const httpServer = createServer(app)

app.use(express.json())
app.use(express.static('public'))

// Routes API
app.use('/api', authRouter)

// Initialiser le serveur de chat avec authentification
const chatServer = new AuthenticatedChatServer(httpServer)

app.get('/', (_req, res) => {
  res.send('Serveur Socket.IO avec authentification')
})

const port = 3000
httpServer.listen(port, () => {
  console.log(`Serveur démarré sur http://localhost:${port}`)
})
```

## Client HTML avec authentification

Créez `public/chat-auth.html` :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Chat avec Authentification</title>
  <style>
    body { font-family: Arial; max-width: 600px; margin: 50px auto; padding: 20px; }
    #loginForm, #chatContainer { display: none; }
    #loginForm.active, #chatContainer.active { display: block; }
    input { width: 80%; padding: 8px; margin: 5px 0; }
    button { padding: 8px 16px; }
    #messages { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
    .system { color: #666; font-style: italic; }
    .error { color: red; }
  </style>
</head>
<body>
  <h1>Chat Socket.IO avec Auth</h1>

  <div id="loginForm" class="active">
    <h2>Connexion</h2>
    <input type="text" id="username" placeholder="Username (admin ou user)" />
    <input type="password" id="password" placeholder="Password" />
    <button id="loginButton">Se connecter</button>
    <p id="loginError" class="error"></p>
    <p><small>Comptes de test : admin/admin123 ou user/user123</small></p>
  </div>

  <div id="chatContainer">
    <p>Connecté en tant que: <strong id="currentUser"></strong> (<span id="userRole"></span>)</p>
    <p>Utilisateurs: <span id="userCount">0</span></p>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Votre message..." />
    <button id="sendButton">Envoyer</button>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    let socket

    document.getElementById('loginButton').addEventListener('click', async () => {
      const username = document.getElementById('username').value.trim()
      const password = document.getElementById('password').value.trim()
      const loginError = document.getElementById('loginError')

      loginError.textContent = ''

      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        })

        if (!response.ok) {
          const error = await response.json()
          loginError.textContent = error.error || 'Erreur de connexion'
          return
        }

        const { token, username: user, role } = await response.json()

        document.getElementById('loginForm').classList.remove('active')
        document.getElementById('chatContainer').classList.add('active')
        document.getElementById('currentUser').textContent = user
        document.getElementById('userRole').textContent = role

        connectToChat(token, user)
      } catch (error) {
        loginError.textContent = 'Erreur réseau'
      }
    })

    function connectToChat(token, username) {
      socket = io('http://localhost:3000', {
        auth: { token }
      })

      const messagesDiv = document.getElementById('messages')
      const messageInput = document.getElementById('messageInput')
      const userCountSpan = document.getElementById('userCount')

      function addMessage(content, isSystem = false) {
        const p = document.createElement('p')
        p.className = isSystem ? 'system' : ''
        p.textContent = content
        messagesDiv.appendChild(p)
        messagesDiv.scrollTop = messagesDiv.scrollHeight
      }

      socket.on('connect', () => {
        addMessage('Connecté au serveur', true)
        socket.emit('join', username)
      })

      socket.on('connect_error', (error) => {
        addMessage(`Erreur: ${error.message}`, true)
      })

      socket.on('user-joined', (data) => {
        addMessage(`${data.username} a rejoint`, true)
        userCountSpan.textContent = data.userCount
      })

      socket.on('user-left', (data) => {
        addMessage(`${data.username} a quitté`, true)
        userCountSpan.textContent = data.userCount
      })

      socket.on('chat-message', (data) => {
        const time = new Date(data.timestamp).toLocaleTimeString()
        addMessage(`[${time}] ${data.username}: ${data.message}`)
      })

      socket.on('error', (data) => {
        addMessage(`Erreur: ${data.message}`, true)
      })

      socket.on('kicked', (data) => {
        alert(`Vous avez été expulsé: ${data.reason}`)
      })

      document.getElementById('sendButton').addEventListener('click', () => {
        const message = messageInput.value.trim()
        if (message) {
          socket.emit('chat-message', message)
          messageInput.value = ''
        }
      })

      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') document.getElementById('sendButton').click()
      })
    }
  </script>
</body>
</html>
```

Ce client (~90 lignes) gère :
- Formulaire de connexion avec username/password
- Récupération du JWT via l'API `/api/login`
- Connexion Socket.IO avec le token dans `auth`
- Affichage du rôle de l'utilisateur connecté
- Gestion des erreurs d'authentification

## Bonnes pratiques

### 1. Variables d'environnement

Ne jamais coder en dur les clés secrètes. Créez un fichier `.env` :

```bash
JWT_SECRET=votre-cle-secrete-tres-longue-et-aleatoire
```

Et utilisez-le dans votre code :

```typescript
import dotenv from 'dotenv'
dotenv.config()

const SECRET_KEY = process.env.JWT_SECRET
if (!SECRET_KEY) {
  throw new Error('JWT_SECRET manquant dans .env')
}
```

### 2. Gestion de l'expiration des tokens

Gérez les différents types d'erreurs JWT :

```typescript
io.use((socket, next) => {
  try {
    const decoded = jwt.verify(token, SECRET_KEY)
    socket.data = decoded
    next()
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      next(new Error('Token expiré, reconnectez-vous'))
    } else {
      next(new Error('Token invalide'))
    }
  }
})
```

### 3. Validation des permissions

Toujours vérifier les permissions côté serveur avant d'autoriser une action :

```typescript
socket.on('admin-action', (data) => {
  if (socket.data.role !== 'admin') {
    return socket.emit('error', { message: 'Permission refusée' })
  }
  // Action autorisée
})
```

### 4. Hachage des mots de passe

Notre exemple utilise des mots de passe en clair pour la simplicité. En production, **toujours** hacher les mots de
passe avec bcrypt :

```bash
npm install bcrypt
npm install --save-dev @types/bcrypt
```

```typescript
import bcrypt from 'bcrypt'

// Lors de la création d'un compte
const hashedPassword = await bcrypt.hash(password, 10)

// Lors de la connexion
const isValid = await bcrypt.compare(password, user.hashedPassword)
```

## Résumé

Nous avons étendu notre classe `ChatServer` pour ajouter l'authentification JWT :

- ✅ **Héritage** : `AuthenticatedChatServer` étend `ChatServer`
- ✅ **Middlewares** : Validation du JWT avant connexion
- ✅ **socket.data** : Stockage des données utilisateur authentifiées
- ✅ **Permissions** : Vérification des rôles (admin/user)
- ✅ **Sécurité** : Variables d'environnement, gestion des erreurs

Dans le prochain chapitre, nous ajouterons les **rooms** pour organiser les utilisateurs en salons de discussion !
