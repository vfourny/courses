---
title: Socket.IO
description: 'Découvrez les WebSockets avec Socket.IO pour créer des applications temps réel'
icon: simple-icons:socketdotio
---

## Introduction

Socket.IO est une bibliothèque qui permet de mettre en place une communication bidirectionnelle en temps réel entre un
client et un serveur. Contrairement aux requêtes HTTP classiques où le client doit toujours initier la communication,
les WebSockets permettent au serveur d'envoyer des données au client à tout moment.

Socket.IO est particulièrement utile pour :

- Les applications de chat en temps réel
- Les notifications en direct
- Les jeux multijoueurs
- Les tableaux de bord avec des données qui se mettent à jour automatiquement
- La collaboration en temps réel (comme Google Docs)

> **Remarque:** Socket.IO utilise WebSocket comme protocole principal, mais peut automatiquement basculer vers d'autres
> méthodes (long polling) si les WebSockets ne sont pas disponibles.

Dans ce chapitre, nous allons organiser notre code Socket.IO de manière modulaire, en suivant l'architecture présentée
au chapitre 13 sur la documentation. Nous verrons aussi deux approches : programmation fonctionnelle et orientée objet.

#### Installation

Pour utiliser Socket.IO, nous devons installer deux packages : un pour le serveur et un pour le client.

```bash
npm install socket.io
npm install --save-dev @types/socket.io
```

Si vous souhaitez utiliser le client dans un projet Node.js (par exemple pour des tests), vous pouvez aussi installer :

```bash
npm install socket.io-client
```

## Serveur de base

Commençons par créer un serveur Socket.IO simple. Socket.IO fonctionne en s'attachant à un serveur HTTP, ce qui signifie
qu'il peut coexister avec Express.

```typescript
import express from 'express'
import { createServer } from 'http'
import { Server } from 'socket.io'

const app = express()
const httpServer = createServer(app)
const io = new Server(httpServer, {
  cors: {
    origin: '*',
  },
})

const port = 3000

// Route Express classique
app.get('/', (req, res) => {
  res.send('Serveur Socket.IO actif')
})

// Écoute des connexions Socket.IO
io.on('connection', (socket) => {
  console.log("Un client s'est connecté:", socket.id)

  socket.on('disconnect', () => {
    console.log("Un client s'est déconnecté:", socket.id)
  })
})

httpServer.listen(port, () => {
  console.log(`Serveur démarré sur http://localhost:${port}`)
})
```

> **Important:** Nous utilisons `httpServer.listen()` et non `app.listen()` car Socket.IO a besoin du serveur HTTP natif
> pour fonctionner.

> **Remarque:** L'option `cors` permet d'autoriser les connexions depuis n'importe quelle origine. En production, vous
> devriez restreindre cela à vos domaines autorisés.

## Événements

Le principe de Socket.IO repose sur l'émission et la réception d'**événements**. Un événement a un nom et peut
transporter des données.

### Recevoir des événements du client

```typescript
io.on('connection', (socket) => {
  console.log('Nouvelle connexion:', socket.id)

  // Écoute d'un événement personnalisé appelé 'message'
  socket.on('message', (data) => {
    console.log('Message reçu:', data)
  })

  // Écoute d'un événement avec plusieurs paramètres
  socket.on('chat-message', (username, message) => {
    console.log(`${username}: ${message}`)
  })
})
```

### Envoyer des événements au client

```typescript
io.on('connection', (socket) => {
  // Envoyer un événement uniquement à ce client
  socket.emit('welcome', 'Bienvenue sur le serveur!')

  // Envoyer à tous les clients connectés
  io.emit('notification', "Un nouvel utilisateur s'est connecté")

  // Envoyer à tous les clients sauf celui-ci
  socket.broadcast.emit('user-joined', socket.id)

  socket.on('message', (data) => {
    // Renvoyer le message à tous les clients (y compris l'émetteur)
    io.emit('message', data)
  })
})
```

Les méthodes principales pour émettre des événements :

- `socket.emit()` : Envoie à ce client uniquement
- `io.emit()` : Envoie à tous les clients connectés
- `socket.broadcast.emit()` : Envoie à tous les clients sauf celui qui émet

## Client HTML simplifié

Pour tester notre serveur, créons un client HTML ultra-simple dans `public/chat-simple.html`. L'objectif est d'avoir le
minimum de code nécessaire pour se connecter et échanger des messages.

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Chat Simple</title>
  <style>
    body { font-family: Arial; max-width: 600px; margin: 50px auto; padding: 20px; }
    #messages { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
    #messageInput { width: 80%; padding: 8px; }
    button { padding: 8px 16px; }
  </style>
</head>
<body>
  <h1>Chat Socket.IO</h1>
  <div id="messages"></div>
  <input type="text" id="messageInput" placeholder="Votre message..." />
  <button id="sendButton">Envoyer</button>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    const socket = io('http://localhost:3000')
    const messagesDiv = document.getElementById('messages')
    const messageInput = document.getElementById('messageInput')

    socket.on('connect', () => {
      messagesDiv.innerHTML += '<p><i>Connecté au serveur</i></p>'
    })

    socket.on('message', (data) => {
      messagesDiv.innerHTML += `<p>${data}</p>`
      messagesDiv.scrollTop = messagesDiv.scrollHeight
    })

    document.getElementById('sendButton').addEventListener('click', () => {
      const message = messageInput.value.trim()
      if (message) {
        socket.emit('message', message)
        messageInput.value = ''
      }
    })

    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('sendButton').click()
    })
  </script>
</body>
</html>
```

Ce client fait exactement ce dont nous avons besoin :
- Connexion au serveur Socket.IO
- Affichage des messages reçus
- Envoi de messages via input et bouton
- Support de la touche Entrée

> **Note :** Nous utilisons le CDN de Socket.IO pour le client. En production, vous installeriez le package et le
> bundleriez avec votre application.

## Exemple complet : Chat avec architecture modulaire

Maintenant que nous avons vu les bases, organisons notre code de manière professionnelle en suivant l'architecture du
chapitre 13. Nous allons séparer nos types, nos handlers et notre initialisation Socket.IO.

### Structure du projet

```
src/
├── socket/
│   ├── types/
│   │   └── socket.types.ts       # Interfaces TypeScript
│   ├── handlers/
│   │   └── chat.handler.ts       # Logique du chat
│   └── index.ts                  # Initialisation Socket.IO
├── index.ts                      # Point d'entrée Express
└── public/
    └── chat.html                 # Client HTML
```

### Types TypeScript

Créez `src/socket/types/socket.types.ts` :

```typescript
// Types pour les événements client → serveur
export interface ClientToServerEvents {
  join: (username: string) => void
  'chat-message': (message: string) => void
}

// Types pour les événements serveur → client
export interface ServerToClientEvents {
  'user-joined': (data: { username: string; userCount: number }) => void
  'user-left': (data: { username: string; userCount: number }) => void
  'chat-message': (data: { username: string; message: string; timestamp: string }) => void
}

// Type pour les données inter-serveur (clusters)
export interface InterServerEvents {}

// Type pour les données stockées dans socket.data
export interface SocketData {}
```

### Handler du chat

Créez `src/socket/handlers/chat.handler.ts` :

```typescript
import { Server, Socket } from 'socket.io'
import { ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData } from '../types/socket.types'

type TypedSocket = Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>
type TypedServer = Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>

// Liste des utilisateurs connectés
const users = new Map<string, string>()

export function setupChatHandlers(io: TypedServer, socket: TypedSocket) {
  console.log(`Nouvelle connexion: ${socket.id}`)

  // Quand un utilisateur rejoint avec un pseudo
  socket.on('join', (username: string) => {
    users.set(socket.id, username)
    io.emit('user-joined', {
      username,
      userCount: users.size,
    })
    console.log(`${username} a rejoint le chat`)
  })

  // Quand un message est envoyé
  socket.on('chat-message', (message: string) => {
    const username = users.get(socket.id) || 'Anonyme'
    io.emit('chat-message', {
      username,
      message,
      timestamp: new Date().toISOString(),
    })
  })

  // Quand un utilisateur se déconnecte
  socket.on('disconnect', () => {
    const username = users.get(socket.id)
    if (username) {
      users.delete(socket.id)
      io.emit('user-left', {
        username,
        userCount: users.size,
      })
      console.log(`${username} a quitté le chat`)
    }
  })
}
```

### Initialisation Socket.IO

Créez `src/socket/index.ts` :

```typescript
import { Server as HTTPServer } from 'http'
import { Server } from 'socket.io'
import { ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData } from './types/socket.types'
import { setupChatHandlers } from './handlers/chat.handler'

export function initSocket(httpServer: HTTPServer) {
  const io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>(httpServer, {
    cors: {
      origin: '*',
    },
  })

  io.on('connection', (socket) => {
    setupChatHandlers(io, socket)
  })

  return io
}
```

### Point d'entrée Express

Modifiez `src/index.ts` :

```typescript
import express from 'express'
import { createServer } from 'http'
import { initSocket } from './socket'

const app = express()
const httpServer = createServer(app)
const io = initSocket(httpServer)

// Servir les fichiers statiques
app.use(express.static('public'))

// Route d'accueil
app.get('/', (_req, res) => {
  res.send('Serveur Socket.IO actif')
})

const port = 3000
httpServer.listen(port, () => {
  console.log(`Serveur de chat démarré sur http://localhost:${port}`)
})
```

### Client HTML complet

Créez `public/chat.html` :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Chat Socket.IO</title>
  <style>
    body { font-family: Arial; max-width: 600px; margin: 50px auto; padding: 20px; }
    #messages { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
    .system { color: #666; font-style: italic; }
    #messageInput { width: 80%; padding: 8px; }
    button { padding: 8px 16px; }
  </style>
</head>
<body>
  <h1>Chat Socket.IO</h1>
  <p>Utilisateurs: <span id="userCount">0</span></p>
  <div id="messages"></div>
  <input type="text" id="messageInput" placeholder="Votre message..." />
  <button id="sendButton">Envoyer</button>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    const socket = io('http://localhost:3000')
    const messagesDiv = document.getElementById('messages')
    const messageInput = document.getElementById('messageInput')
    const userCountSpan = document.getElementById('userCount')

    const username = prompt('Entrez votre pseudo:') || 'Anonyme'
    socket.emit('join', username)

    function addMessage(content, isSystem = false) {
      const p = document.createElement('p')
      p.className = isSystem ? 'system' : ''
      p.textContent = content
      messagesDiv.appendChild(p)
      messagesDiv.scrollTop = messagesDiv.scrollHeight
    }

    socket.on('connect', () => addMessage('Connecté au serveur', true))

    socket.on('user-joined', (data) => {
      addMessage(`${data.username} a rejoint`, true)
      userCountSpan.textContent = data.userCount
    })

    socket.on('user-left', (data) => {
      addMessage(`${data.username} a quitté`, true)
      userCountSpan.textContent = data.userCount
    })

    socket.on('chat-message', (data) => {
      const time = new Date(data.timestamp).toLocaleTimeString()
      addMessage(`[${time}] ${data.username}: ${data.message}`)
    })

    document.getElementById('sendButton').addEventListener('click', () => {
      const message = messageInput.value.trim()
      if (message) {
        socket.emit('chat-message', message)
        messageInput.value = ''
      }
    })

    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('sendButton').click()
    })
  </script>
</body>
</html>
```

Ce client est simple et concis (60 lignes) avec le minimum de CSS nécessaire. Il affiche les utilisateurs connectés,
les messages du chat, et permet d'envoyer des messages.

## Approche orientée objet avec classes

Jusqu'à présent, nous avons utilisé une approche fonctionnelle. TypeScript supporte aussi la programmation orientée
objet avec des classes. Voici comment implémenter notre chat avec cette approche.

### Pourquoi utiliser des classes ?

Les classes permettent de :
- **Encapsuler** les données et les méthodes liées
- **Organiser** le code de manière plus structurée
- **Faciliter** la réutilisation et la maintenance
- **Utiliser** l'héritage et le polymorphisme

### Classe ChatServer

Créez `src/socket/classes/ChatServer.ts` :

```typescript
import { Server as HTTPServer } from 'http'
import { Server, Socket } from 'socket.io'
import { ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData } from '../types/socket.types'

type TypedSocket = Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>
type TypedServer = Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>

export class ChatServer {
  private io: TypedServer
  private users: Map<string, string>

  constructor(httpServer: HTTPServer) {
    this.io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>(httpServer, {
      cors: { origin: '*' },
    })
    this.users = new Map()
    this.initializeHandlers()
  }

  private initializeHandlers() {
    this.io.on('connection', (socket) => {
      this.handleConnection(socket)
    })
  }

  private handleConnection(socket: TypedSocket) {
    console.log(`Nouvelle connexion: ${socket.id}`)

    socket.on('join', (username) => this.handleJoin(socket, username))
    socket.on('chat-message', (message) => this.handleMessage(socket, message))
    socket.on('disconnect', () => this.handleDisconnect(socket))
  }

  private handleJoin(socket: TypedSocket, username: string) {
    this.users.set(socket.id, username)
    this.io.emit('user-joined', {
      username,
      userCount: this.users.size,
    })
    console.log(`${username} a rejoint le chat`)
  }

  private handleMessage(socket: TypedSocket, message: string) {
    const username = this.users.get(socket.id) || 'Anonyme'
    this.io.emit('chat-message', {
      username,
      message,
      timestamp: new Date().toISOString(),
    })
  }

  private handleDisconnect(socket: TypedSocket) {
    const username = this.users.get(socket.id)
    if (username) {
      this.users.delete(socket.id)
      this.io.emit('user-left', {
        username,
        userCount: this.users.size,
      })
      console.log(`${username} a quitté le chat`)
    }
  }

  public getIO() {
    return this.io
  }

  public getUserCount() {
    return this.users.size
  }
}
```

### Utilisation de la classe

Modifiez `src/index.ts` pour utiliser la classe :

```typescript
import express from 'express'
import { createServer } from 'http'
import { ChatServer } from './socket/classes/ChatServer'

const app = express()
const httpServer = createServer(app)

// Initialiser le serveur de chat avec la classe
const chatServer = new ChatServer(httpServer)

app.use(express.static('public'))

app.get('/', (_req, res) => {
  res.send('Serveur Socket.IO actif')
})

const port = 3000
httpServer.listen(port, () => {
  console.log(`Serveur de chat démarré sur http://localhost:${port}`)
  console.log(`Utilisateurs connectés: ${chatServer.getUserCount()}`)
})
```

### Avantages de cette approche

✅ **Encapsulation** : Les données (`users`, `io`) sont privées et protégées

✅ **Organisation** : Chaque méthode a une responsabilité claire

✅ **Lisibilité** : Le code est plus structuré et facile à comprendre

✅ **Extensibilité** : Facile d'ajouter de nouvelles fonctionnalités (méthodes)

✅ **Testabilité** : Plus facile de tester chaque méthode individuellement

### Quelle approche choisir ?

**Approche fonctionnelle** (avec handlers) :
- Plus simple pour les petits projets
- Moins de boilerplate
- Style plus proche de JavaScript moderne

**Approche orientée objet** (avec classes) :
- Meilleure pour les projets complexes
- Plus facile à étendre et maintenir
- Familière pour les développeurs venant de Java, C#, etc.

> **Conseil** : Dans les chapitres suivants, nous continuerons d'utiliser l'approche avec classes pour montrer comment
> étendre facilement notre application avec l'authentification et les rooms.

## Bonnes pratiques

### 1. Typage strict

Nous avons vu comment typer les événements Socket.IO avec TypeScript. C'est essentiel pour :
- Éviter les erreurs de typage
- Bénéficier de l'autocomplétion dans votre IDE
- Documenter implicitement votre API temps réel

### 2. Gestion des erreurs

Pensez à gérer les erreurs de connexion côté client :

```typescript
socket.on('connect_error', (error) => {
  console.error('Erreur de connexion:', error.message)
})

socket.on('error', (error) => {
  console.error('Erreur socket:', error)
})
```

### 3. Nettoyage des ressources

Toujours nettoyer les données lors des déconnexions pour éviter les fuites mémoire :

```typescript
socket.on('disconnect', (reason) => {
  console.log('Déconnexion:', reason)
  users.delete(socket.id)
  // Nettoyer toutes les ressources liées à ce socket
})
```

### 4. Configuration CORS en production

En production, ne jamais utiliser `origin: '*'`. Spécifiez vos domaines autorisés :

```typescript
const io = new Server(httpServer, {
  cors: {
    origin: ['https://monapp.com', 'https://www.monapp.com'],
    credentials: true,
  },
})
```

> **Note :** Socket.IO gère automatiquement la reconnexion en cas de perte de connexion temporaire. Dans les prochains
> chapitres, nous verrons comment sécuriser ces connexions avec l'authentification JWT et organiser les utilisateurs
> en rooms.
