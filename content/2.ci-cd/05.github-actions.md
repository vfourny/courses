---
title: GitHub Actions
description: 'Automatisez vos tests et vÃ©rifications avec la CI/CD de GitHub'
icon: i-simple-icons-githubactions
---

**GitHub Actions** est un outil d'automatisation intÃ©grÃ© Ã  GitHub qui permet d'exÃ©cuter des **workflows** (flux de travail) automatiquement en rÃ©ponse Ã  des Ã©vÃ©nements (push, pull request, etc.).

#### Cas d'usage

- ExÃ©cuter des tests Ã  chaque push
- VÃ©rifier le formatage du code
- Valider les commits
- DÃ©ployer automatiquement en production
- Publier des packages npm
- Envoyer des notifications

#### Pourquoi c'est important ?

Sans CI/CD, vous devez manuellement :

1. VÃ©rifier que le code compile
2. ExÃ©cuter tous les tests
3. VÃ©rifier le linting
4. S'assurer que le formatage est correct

**ProblÃ¨me** : Si un dÃ©veloppeur oublie une Ã©tape, du code cassÃ© peut Ãªtre mergÃ©. Avec GitHub Actions, tout est automatique et garanti :icon{name="i-heroicons-check-circle" class="text-green-500"}

## Concepts de base

#### Workflow

Un **workflow** est un fichier YAML qui dÃ©finit les actions Ã  exÃ©cuter. Il est stockÃ© dans `.github/workflows/`.

#### Job

Un **job** est un ensemble d'Ã©tapes (steps) qui s'exÃ©cutent sur une machine virtuelle.

#### Step

Une **step** est une action individuelle (installer des dÃ©pendances, exÃ©cuter des tests, etc.).

#### Event

Un **event** dÃ©clenche l'exÃ©cution d'un workflow (`push`, `pull_request`, `schedule`, etc.).

## Notre premier workflow

Nous allons crÃ©er un workflow qui s'exÃ©cute Ã  chaque **pull request** et vÃ©rifie :

1. Que le code compile
2. Que les tests passent
3. Que le linting est correct
4. Que le formatage est bon

### CrÃ©er le fichier workflow

CrÃ©ez le fichier `.github/workflows/ci.yml` :

```yaml
name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  test:
    name: Test and Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Check code formatting
        run: npm run format:check

      - name: Run type checking
        run: npm run typecheck

      - name: Run tests
        run: npm run test
```

### Explication du workflow

**DÃ©clencheurs** :

```yaml
on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
```

- Le workflow s'exÃ©cute Ã  chaque **pull request** vers `main`
- Et Ã  chaque **push** sur `main`

**Job** :

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
```

- Nom du job : `test`
- S'exÃ©cute sur Ubuntu (machine virtuelle GitHub)

**Steps** :

1. **Checkout** : RÃ©cupÃ¨re le code du repository

```yaml
- uses: actions/checkout@v4
```

2. **Setup Node.js** : Installe Node.js

```yaml
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'
```

3. **Installer les dÃ©pendances** :

```yaml
- run: npm ci
```

`npm ci` est plus rapide que `npm install` et utilise le `package-lock.json`.

4. **ExÃ©cuter les vÃ©rifications** :

```yaml
- run: npm run lint
- run: npm run format:check
- run: npm run typecheck
- run: npm run test
```

### Scripts nÃ©cessaires

Assurez-vous que votre `package.json` contient les scripts :

```json
{
  "scripts": {
    "lint": "eslint .",
    "format:check": "prettier --check .",
    "typecheck": "tsc --noEmit",
    "test": "vitest run"
  }
}
```

## Tester le workflow

1. **CrÃ©ez une branche** :

```bash
git checkout -b test-ci
```

2. **Faites une modification** :

```bash
echo "console.log('test');" >> src/index.ts
```

3. **Commit et push** :

```bash
git add .
git commit -m "feat: test CI workflow"
git push origin test-ci
```

4. **CrÃ©ez une Pull Request** sur GitHub

5. **Observez l'exÃ©cution** :

- Allez sur votre repository GitHub
- Onglet **Pull requests** â†’ Votre PR
- Vous verrez le workflow s'exÃ©cuter en temps rÃ©el

Si tout est vert :icon{name="i-heroicons-check-circle" class="text-green-500"}, le code est prÃªt Ã  Ãªtre mergÃ© !
Si des erreurs apparaissent :icon{name="i-heroicons-x-circle" class="text-red-500"}, le code doit Ãªtre corrigÃ©.

## Protections de branche

Pour **forcer** que la CI passe avant de merger, configurez des **branch protection rules**.

### Configuration

1. **Allez sur votre repository GitHub**
2. **Settings** â†’ **Branches** â†’ **Add rule**
3. **Branch name pattern** : `main`
4. **Cochez** :
   - :icon{name="i-heroicons-check-circle" class="text-green-500"} **Require a pull request before merging**
   - :icon{name="i-heroicons-check-circle" class="text-green-500"} **Require status checks to pass before merging**
   - :icon{name="i-heroicons-check-circle" class="text-green-500"} **Require branches to be up to date before merging**
5. **SÃ©lectionnez les checks** : `Test and Lint`
6. **Save changes**

### RÃ©sultat

Maintenant, **impossible de merger** une PR si :

- Les tests Ã©chouent :icon{name="i-heroicons-x-circle" class="text-red-500"}
- Le linting Ã©choue :icon{name="i-heroicons-x-circle" class="text-red-500"}
- Le formatage est incorrect :icon{name="i-heroicons-x-circle" class="text-red-500"}
- Le type checking Ã©choue :icon{name="i-heroicons-x-circle" class="text-red-500"}

Seul du code valide peut Ãªtre mergÃ© ! ðŸŽ‰

## Protections supplÃ©mentaires

#### Require pull request reviews

Obligez au moins **1 revue** avant de merger :

**Settings** â†’ **Branches** â†’ **Branch protection rule** :

- :icon{name="i-heroicons-check-circle" class="text-green-500"} **Require approvals** : `1`

#### Dismiss stale reviews

Si le code change aprÃ¨s une revue, annulez l'approbation :

- :icon{name="i-heroicons-check-circle" class="text-green-500"} **Dismiss stale pull request approvals when new commits are pushed**

#### Require conversation resolution

Obligez Ã  rÃ©soudre tous les commentaires avant de merger :

- :icon{name="i-heroicons-check-circle" class="text-green-500"} **Require conversation resolution before merging**

## Secrets et variables d'environnement

Pour des donnÃ©es sensibles (clÃ©s API, tokens), utilisez les **GitHub Secrets** :

1. **Settings** â†’ **Secrets and variables** â†’ **Actions** â†’ **New repository secret**
2. Nom : `JWT_SECRET`
3. Valeur : `votre-secret`

Utilisez-le dans votre workflow :

```yaml
env:
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
```